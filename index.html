<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Image Scrubber</title>
</head>
<style>

#imageCanvas{
    position: absolute;
    top: 56%;
    left: 50%;
    transform: translateX(-50%) translateY(-50%);
    max-width: 100%;
    max-height: 82%;
    z-index: -1;
    cursor: crosshair;
}

#topBar{
    width:100%;
    height:12vh;
    border: 1px solid black;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    box-sizing: border-box;
}


.topBarDiv{
    width: 18vw;
    height: 12vh;
    border-left: 1px solid #ccc;
    border-right: 1px solid #ccc;
    display: flex;
    align-items: center;
    justify-content: center;
}


#file-input{
    flex-direction: row;
}

#saveButton{
    padding-top: 2px;
    cursor: pointer;

}

#openDiv{
    padding-top: 2px;
}

#exifInformationHolder{
    padding: 10px;
    border: 1px solid black;
    position: absolute;
    left: 0;
    right: 0;
    margin-right: auto;
    margin-left: auto;
    max-width: 70%;
    max-width: 600px;
    max-height: 85%;
    background-color: white;
    display: none;
    z-index: 2;

    position: absolute;
    top: 55%;
    transform: translateY(-50%);
    max-height: 88%;
}

#imageScrubberInfo{
    position: absolute;
    left: 0;
    right: 0;
    margin-right: auto;
    margin-left: auto;
    padding: 10px;
    width: 80%;
    max-width: 600px;
    max-height: 88%;
    background-color: white;
    display: block;
    z-index: 3;
    font-size: 14px;
    overflow: auto;
    box-sizing: border-box;
}


@media (max-width: 800px) {
    #imageScrubberInfo {
        max-height: 75%;
    }


 #topBar {
    flex-wrap: wrap;
    height:20vh;
    align-items: flex-start;
  }


.topBarDiv{
    width: 33vw;
    height: 8vh;
    max-height:10vh;
    border: 0px solid #ccc;
    border-left: 0px solid #ccc;
    border-right: 0px solid #ccc;

}


#imageCanvas{
    position: absolute;
    top: 58%;
    max-height: 75%;
}

#continueButtonExif{
    position: absolute;
    bottom: 10%;
    left: 50%;
    transform: translateX(-50%) translateY(-50%);
}
}

#exifScrollDiv{
    position: inline-block;
    height: 75vh;
    max-height: 75vh;
    overflow-y: auto;

}

#tempCanvas {
    position:absolute;
    top:-1000px;
    display: none;
}

#holderCanvas {
    position:absolute;
    top:-1000px;
    display: none;
}

#rotationCanvas {
    position:absolute;
    top:-1000px;
    display: none;
}

#about{
  position:absolute;
  bottom: 10px;
  right: 10px;
  z-index: 20;

}

body{
    font-family: Courier;
    margin: 0;
    padding: 0;
    font-size: 12px;
    overflow: hidden;
}

button{
font-family: Courier;
    font-size: 12px;
}

#continueButton, #continueButtonExif{
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 40%;
}


input[type="file"] {
    display: none;
}

.file-open {
    border: 1px solid #ccc;
    display: inline-block;
    padding: 6px 12px;
    cursor: pointer;
}

/* The slider itself */
.slider {
  width: 95%; /* Full-width */
}

pre {
 white-space: pre-wrap;       /* css-3 */
 white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
 white-space: -pre-wrap;      /* Opera 4-6 */
 white-space: -o-pre-wrap;    /* Opera 7 */
 word-wrap: break-word;       /* Internet Explorer 5.5+ */

}

#rotate{
        cursor: pointer;
}

.custom-file-open{
    cursor: pointer;
}
</style>
<body>

<div id="topBar">

    <div id="openDiv" class="topBarDiv" class="custom-file-open"><center>
    <label for="file-input" class="custom-file-open"><center>
    Open image ðŸ“‚</center>
    </label>
    <input id="file-input" type="file"/></center></div>

<a id="saveButton" onclick="saveImage(this)" class="topBarDiv"><center>Save image ðŸ’¾</center></a>


<div id="rotate" class="topBarDiv"><center>Rotate Image â¤¾</center></div>


<div id="paintBlur" class="topBarDiv" class="custom-file-open"><center>
<form id="paintForm">
<input type="radio" id="Paint" name="paintingAction" value="paint">
<label for="Paint">Paint</label><br>
<input type="radio" id="Blur" name="paintingAction" value="blur" checked>
<label for="Blur">Blur&nbsp;</label><br>
<input type="radio" id="Undo" name="paintingAction" value="undo">
<label for="Undo">Undo&nbsp;</label>
</form>
</center>
</div>


<div id="brushSizeDiv" class="topBarDiv"><center> Brush Size<br>
  <input type="range" min="1" max="100" value="50" class="slider" id="brushSize"></center>
</div>

<div id="blurAmountDiv" class="topBarDiv"><center> Blur Radius<br>
  <input type="range" min="20" max="130" value="75" class="slider" id="blurAmount"></center>
</div>
</div>

<button id="about">About</button>

<div id="imageScrubberInfo">
<pre>
<center><b>Image Scrubber</b></center>

This is a tool for anonymizing photographs taken at protests. 

It will remove identifying metadata (<a href="https://en.wikipedia.org/wiki/Exif">Exif data</a>) from photographs, and also allow you to selectively blur parts of the image to cover faces and other identifiable information. 

Hit the open button to open a photograph. The program will display the data it is removing.

Click okay, and you can then save the scrubbed image by hitting save or right clicking on it and saving it. Maximum size is 2500x2500 pixels - larger images will be scaled down.

You can select between painting over the image or blurring it out. Dragging on the image will paint on or blur it. You can change your brush size via the slider. The blur function has built-in pixelization and noise and is fairly irreversible - but very sensitive information should be covered with the paint tool.

<strong>All processing happens directly in the browser- no information is stored or sent anywhere.</strong>

This website also works offline, and there are two such ways to use it. 

The first is to turn on airplane mode (or turn off wifi/mobile data) before uploading any pictures. 

The second (harder on mobile) is to (<a href="https://github.com/everestpipkin/image-scrubber/archive/master.zip">download</a> the repository, extract/unzip the folder, and run index.html in a web browser of your choice.  

Alternatively, if you know how to use the git CLI and have it set up, you can clone this repo by using the following command: 
git clone https://github.com/everestpipkin/image-scrubber 
instead of downloading from the link.

Once again, turn on airplane mode or turn off connectivity before actually using the tool.


Bug reports or questions to: everest.pipkin@gmail.com

Github repo at <a href="https://github.com/everestpipkin/image-scrubber" target="_blank">github.com/everestpipkin/image-scrubber</a>

If you want other ways to cover your digital footprint, I've assembled a list of resources: via <a href="https://docs.google.com/document/d/1615pZB11BhsR0KtvyiXfzfMUBlxZi47HzzhWHIRpxwU/edit" target="_blank">Google Doc</a> or <a href="https://pastebin.com/TPgtvmVB" target="_blank">Pastebin</a>.
</pre>

</div>

    <div id="exifInformationHolder"></div>
    <canvas id="imageCanvas"></canvas>
    <canvas id="tempCanvas"></canvas>
    <canvas id="holderCanvas"></canvas>
    <canvas id="rotationCanvas"></canvas>

    <script type="text/javascript" src="exif.js"></script>
    <script type="text/javascript" src="stackblur.js"></script>

    <script>

var filename;
var img;

var isDown = false;
var painting = false;

var canvas = document.getElementById('imageCanvas');
var ctx = canvas.getContext('2d');

var tempCanvas = document.getElementById("tempCanvas");
var tempCtx = tempCanvas.getContext("2d");

var holderCanvas = document.getElementById("holderCanvas");
var holderCtx = holderCanvas.getContext("2d");

var rotationCanvas = document.getElementById("rotationCanvas");
var rotationCtx = rotationCanvas.getContext("2d");

var brushSize = 50;
var blurAmount = 50;

//blur amount needs to be set for the size of the canvas ...
//100 x 100 is arond 5, 2500 x 2500 is around 100
//i map this later on in the set canvas size


canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('mouseout', handleMouseOut);

canvas.addEventListener('touchstart', handleMouseDown);
canvas.addEventListener('touchmove', handleTouchMove);
canvas.addEventListener('touchend', handleMouseUp);
canvas.addEventListener('touchcancel', handleMouseUp);


var brushSizeDiv = document.getElementById("brushSize");
brushSizeDiv.onchange = populateBrushSize;

var blurAmountDiv = document.getElementById("blurAmount");
blurAmountDiv.onchange = populateBlurAmount;

function populateBrushSize(){
    brushSize = Math.floor(this.value * canvas.width/800);
    setCursor();
}

function populateBlurAmount(){
    blurAmount = Math.floor(this.value);
}


function setCursor(){

    var cursorCanvas = document.createElement('canvas');
    var scaleX = canvas.getBoundingClientRect().width / canvas.width;
    cursorCanvas.width = ((brushSize*2)*scaleX);
    cursorCanvas.height = ((brushSize*2)*scaleX);
    var cursorCtx = cursorCanvas.getContext('2d');

    cursorCtx.beginPath();
    cursorCtx.arc(cursorCanvas.width / 2, cursorCanvas.height / 2, (brushSize)*scaleX, 0, Math.PI * 2);
    cursorCtx.closePath();
    cursorCtx.stroke(); 
    var cursorDataURL = cursorCanvas.toDataURL();
    canvas.style.cursor = "url("+cursorDataURL+") " + cursorCanvas.width / 2 +" "+ cursorCanvas.height / 2 + ", auto";

}
// get list of radio buttons with name 'paintForm'
var sz = document.forms['paintForm'].elements['paintingAction'];

// loop through list
for (var i=0, len=sz.length; i<len; i++) {
    sz[i].onclick = function() { 
        //console.log(this.value)
        painting = this.value;
    };
}

function saveImage(){
  document.getElementById('imageCanvas').toBlob(function (blob) {
    var link = document.createElement('a');
    link.download = filename;
    link.href = URL.createObjectURL(blob);
    link.click();
  }, 'image/jpeg', 0.8);
}

document.getElementById("file-input").onchange = function(e) {

    var reader = new FileReader();
    reader.onload = function(event){
        img = new Image();
        img.onload = function(){
            if (img.width < 2500 && img.height < 2500){
                var canvasScale = 1;
        }
        else {
            var canvasScale = Math.min(2500 / img.width, 2500 / img.height)
        }
            //console.log(canvasScale)

            canvas.width = tempCanvas.width = holderCanvas.width = rotationCanvas.width = img.width*canvasScale;
            canvas.height = tempCanvas.height = holderCanvas.height = rotationCanvas.height = img.height*canvasScale;
            ctx.drawImage(img,0,0,img.width*canvasScale,img.height*canvasScale);
            rotationCtx.drawImage(img,0,0,img.width*canvasScale,img.height*canvasScale);

            var biggerDimension = Math.max(canvas.width, canvas.height);

            setCursor()

            // i need to come back to this - blur amount and brush size deviate at big and small images

            brushSize = scale(biggerDimension, 10, 2500, 20, 100); //Math.floor(50 * canvas.width/800);
            blurAmount = brushSize/2;//scale(biggerDimension, 10, 2500, 1, 75);
            //console.log(brushSize)
        }
        img.src = event.target.result;
    }
    reader.readAsDataURL(e.target.files[0]);    

            filename = document.getElementById("file-input").value;
            //console.log(e.target)
            var exifInformationDiv = document.getElementById("exifInformationHolder");
            var imageScrubberInfo = document.getElementById("imageScrubberInfo");
            imageScrubberInfo.style.display = "none";
            exifInformationDiv.style.display = "block";
            var file = e.target.files[0]
            if (file && file.name) {
                EXIF.getData(file, function() {

                    var exifData = JSON.stringify(this.exifdata, null, 4);
                    if (exifData) {
                        //console.log(exifData)
                        if (exifData.toString() == "{}"){
                            exifInformationHolder.innerHTML = "<center>No EXIF data found in image '" + file.name + "'.<br><br></center>";
                        var btn = document.createElement("BUTTON");
                        btn.id="continueButton";
                        btn.innerHTML = "Continue to edit image";
                        btn.onclick = goToBlur;
                        exifInformationHolder.appendChild(btn)
                        }
                        else{
                        var exifScrollDiv = document.createElement("div");
                        exifScrollDiv.id = "exifScrollDiv"
                        //var exifScrollDiv = document.getElementById("exifScrollDiv");
                        exifScrollDiv.innerHTML =  file.name + "<pre>" + exifData + "</pre>";
                        exifInformationHolder.innerHTML = "Exif Data:<br><br>"
                        exifInformationHolder.appendChild(exifScrollDiv)
                        
                        var btn = document.createElement("BUTTON");
                        btn.id="continueButtonExif";
                        btn.innerHTML = "Scrub Exif Data";
                        btn.onclick = scrubData;
                        exifInformationHolder.appendChild(btn)
                    }
                    }
                });
            }
        }

function scrubData(){
    document.getElementById("exifInformationHolder").style.display = "none";
    alert("EXIF data removed: you may now save the image");
}

function goToBlur(){
    document.getElementById("exifInformationHolder").style.display = "none";
}


function handleMouseDown(e) {
    //console.log(e)
    e.preventDefault();
    e.stopPropagation();

    holderCtx.save();
    holderCtx.clearRect(0, 0, holderCanvas.width, holderCanvas.height);
    holderCtx.drawImage(canvas, 0, 0);
    holderCtx.restore();

    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
    isDown = true;
}

//weird bug where it doesn't blur / crashes if you leave w mouse pressed, fix soon
function handleMouseOut(e) {
    e.preventDefault();
    e.stopPropagation();
    isDown = false;
}

function handleMouseMove(e) {

    var pos = getMousePos(canvas, e);
    posx = pos.x;
    posy = pos.y;

    if (!isDown) {
        return;
    }
    e.preventDefault();
    e.stopPropagation();
    mouseX = pos.x; 
    mouseY = pos.y; 

    ctx.beginPath();
    ctx.arc(mouseX, mouseY, brushSize, 0, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
    tempCtx.beginPath();
    tempCtx.arc(mouseX, mouseY, brushSize, 0, Math.PI * 2);
    tempCtx.closePath();
    tempCtx.fill();
}



function handleTouchMove(e) {


    if (e.touches.length > 1){  // Ignor multi touch events
        return;
    }

    touch = event.changedTouches[0]; // get the position information

//console.log(touch)

    var mouseEvent = new MouseEvent( // create event
    "mousemove",   // type of event
    {
        'view': event.target.ownerDocument.defaultView,
        'bubbles': true,
        'cancelable': true,
        'screenX':touch.screenX,  // get the touch coords 
        'screenY':touch.screenY,  // and add them to the 
        'clientX':touch.clientX,  // mouse event
        'clientY':touch.clientY,
        });
        // send it to the same target as the touch event contact point.
    touch.target.dispatchEvent(mouseEvent);

    var pos = getMousePos(canvas, e);
    posx = pos.x;
    posy = pos.y;

    if (!isDown) {
        return;
    }
    e.preventDefault();
    e.stopPropagation();
    mouseX = pos.x; 
    mouseY = pos.y; 
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, brushSize, 0, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
    tempCtx.beginPath();
    tempCtx.arc(mouseX, mouseY, brushSize, 0, Math.PI * 2);
    tempCtx.closePath();
    tempCtx.fill();
}

function handleMouseUp(e) {
    e.preventDefault();
    e.stopPropagation();
    isDown = false;
    if (painting != "paint"){
        var tempBlurAmount = blurAmount;
        if (painting == "undo"){
            blurAmount = 0;
        }
        tempCtx.save();
        tempCtx.globalCompositeOperation = "source-in";
        tempCtx.drawImage(rotationCanvas, 0, 0);
        tempCtx.restore();
        //pixelate function is here
        if (painting != "undo"){
        pixelateCanvas(tempCanvas, tempCtx, 10);
        }
        stackBlurCanvasRGBA("tempCanvas", 0, 0, tempCanvas.width, tempCanvas.height, blurAmount);
        ctx.save();
        //ctx.globalCompositeOperation = "screen";
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(tempCanvas, 0, 0);
        ctx.globalCompositeOperation = "destination-over";
        ctx.drawImage(holderCanvas, 0, 0);
        ctx.restore();
        blurAmount = tempBlurAmount;
    }
}



function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    //console.log(rect);
    return {
        x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width,
        y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height
    };
}


var button = document.getElementById("rotate");
button.onclick = function () {
    // rotate the canvas 90 degrees each time the button is pressed
    rotate();
}


var button = document.getElementById("about");
button.onclick = function () {

    var imageScrubberInfo = document.getElementById("imageScrubberInfo");
    if (imageScrubberInfo.style.display == "none"){

        imageScrubberInfo.style.display = "block";

    }
    else{
       imageScrubberInfo.style.display = "none"; 
    }

}


var myImageData, tempImageData, holderImageData, rotating = false;   

var rotate = function () {
    if (!rotating) {
        rotating = true;            
        // store current data to an image
        myImageData = new Image();
        tempImageData = new Image();
        rotationImageData = new Image();
        myImageData.src = canvas.toDataURL();
        tempImageData.src = tempCanvas.toDataURL();
        rotationImageData.src = rotationCanvas.toDataURL();
        //holderImageData.src = holderCanvas.toDataURL();


       myImageData.onload = function () {
            // reset the canvas with new dimensions
            cw = canvas.width;
            ch = canvas.height;
            canvas.width = ch;
            canvas.height = cw;
            tempCanvas.width = ch;
            tempCanvas.height = cw;
            holderCanvas.width = ch;
            holderCanvas.height = cw;
            rotationCanvas.width = ch;
            rotationCanvas.height = cw;
            cw = canvas.width;
            ch = canvas.height;

            ctx.save();
            // translate and rotate
            ctx.translate(cw, ch / cw);
            ctx.rotate(Math.PI / 2);
            // draw the previows image, now rotated
            ctx.drawImage(myImageData, 0, 0);               
            ctx.restore();

            tempCtx.save();
            // translate and rotate
            tempCtx.translate(cw, ch / cw);
            tempCtx.rotate(Math.PI / 2);
            // draw the previows image, now rotated
            tempCtx.drawImage(tempImageData, 0, 0);               
            tempCtx.restore();


            rotationCtx.save();
            // translate and rotate
            rotationCtx.translate(cw, ch / cw);
            rotationCtx.rotate(Math.PI / 2);
            // draw the previows image, now rotated
            rotationCtx.drawImage(rotationImageData, 0, 0);               
            rotationCtx.restore();

            //holderCtx.save();
            // translate and rotate
            //holderCtx.translate(cw, ch / cw);
            //holderCtx.rotate(Math.PI / 2);
            // draw the previows image, now rotated
            //holderCtx.drawImage(holderImageData, 0, 0);               
            //holderCtx.restore();

            // clear the temporary image
            myImageData = null;
            tempImageData = null;
            //holderImageData = null;
            rotating = false;               
        }
    }
}



const scale = (num, in_min, in_max, out_min, out_max) => {
  return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

function pixelateCanvas(inCanvas, inCtx, blockSize){

    // so - smaller canvases need to be bigger block size, because they get too small to render anything
    //a 10x10 pixel image should be around .5
    //a 2500x2500 should be around 0.03
    //just gonna use a map function for now- see above

    var biggerDimension = Math.max(inCanvas.width, inCanvas.height);

    var size = scale(biggerDimension, 10, 2500, 0.5, 0.06); // 150
    //console.log(size);
    w = inCanvas.width * size;
    h = inCanvas.height * size;

    // create offscreen image
    var offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;

    var offscreenCtx = offscreenCanvas.getContext('2d');

    // turn off image aliasing
    offscreenCtx.msImageSmoothingEnabled = false;
    offscreenCtx.mozImageSmoothingEnabled = false;
    offscreenCtx.webkitImageSmoothingEnabled = false;
    offscreenCtx.imageSmoothingEnabled = false;

    offscreenCtx.drawImage(inCanvas, 0, 0, w, h);
    inCtx.save();

    // enlarge the minimized image to full size and draw to main canvas  
    inCtx.drawImage(offscreenCanvas, 0, 0, w, h, 0, 0, inCanvas.width, inCanvas.height);

    pixelArray = offscreenCtx.getImageData(0, 0, w, h);
    pixelArray.data = shuffle(pixelArray.data)
    //pixelArray.data = noise(pixelArray.data) // this induces colorful noise but its unneeded i think
    //console.log(pixelArray.data)
    offscreenCtx.putImageData(pixelArray, 0,0);

    // enlarge the minimized image to full size and draw to main canvas  
    inCtx.drawImage(offscreenCanvas, 0, 0, w, h, 0, 0, inCanvas.width, inCanvas.height);

    inCtx.restore();
    //holderCtx.restore();

}


//not in atm but could add back in if wanted for even more ~security~. honestly not needed though, the shuffle does the work
function noise(array) {
    let counter = array.length;


    while (counter > 0) {
        counter--;

        if (array[counter] != 0){
        array[counter] = Math.floor(Math.random() * 255) //array[counter + Math.floor(Math.random() * 20)];
    }
    }

    return array;
}


function shuffle(array) {

var holderArray = []

    for(var i = 0, n = array.length; i < n; i += 4) {
          var red = array[i];
          var green = array[i + 1];
          var blue = array[i + 2];
          //var alpha = array[i + 3];

          if (red+green+blue != 0){
            //console.log(i)
            holderArray.push(i);
          }
    }

//items[Math.floor(Math.random() * items.length)];

    for(x = 0; x < holderArray.length; x++) {

        //gets a random element within canvas.width/75 pixels of this one - in the linear array, kind of silly but it works! might want to come back through and do something nicer but its getting blurred anyway so eh
    
            var randomElement = x + (Math.floor(Math.random() * (canvas.width/75)));
            //console.log(randomElement, holderArray.length)
            if (randomElement > holderArray.length || randomElement < 0){
                randomElement = x;
            }
        
            //console.log(randomElement, holderArray.length)

        //console.log(randomElement)
          array[holderArray[x]] = array[holderArray[randomElement]];
          array[holderArray[x] + 1] = array[holderArray[randomElement] +1];
          array[holderArray[x] + 2] = array[holderArray[randomElement] +2];
          //var alpha = array[i + 3];
}
    return array;
}
//bits of this code lifted and adapted from various jsfiddles and libraries -- 
//thank you:
//http://jsfiddle.net/sierawski/4xezb7nL/
//https://stackoverflow.com/questions/22604903/needed-canvas-blurring-tool
//http://jsfiddle.net/m1erickson/baDLp/
//view-source:https://storage.flother.is/etc/2010/examples/canvas-blur/v3/canvas-image.js
//http://quasimondo.com/StackBlurForCanvas/StackBlur.js
//https://github.com/exif-js/exif-js
//http://jsfiddle.net/4cwpLvae/
//https://stackoverflow.com/questions/16645801/rotate-canvas-90-degrees-clockwise-and-update-width-height
//https://stackoverflow.com/questions/19129644/how-to-pixelate-an-image-with-canvas-and-javascript
//https://devbutze.blogspot.com/2014/02/html5-canvas-offscreen-rendering.html



/// // // / 

    </script>
</body>
</html>
